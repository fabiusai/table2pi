<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel to SVG Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            margin: 0;
            padding: 0;
        }

        .container {
            width: 100%;
            max-width: none;
            margin: 0;
            padding: 20px;
        }

        header {
            background-color: #fff;
            padding: 30px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 40px;
        }

        h1 {
            color: #1d48b4;
            font-size: 2.5em;
            font-weight: 700;
            text-align: center;
            font-family: 'Avenir Next LT Pro', sans-serif;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-top: 10px;
            font-size: 1.1em;
        }

        .main-content {
            background-color: #fff;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background-color: #fafafa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
        }

        .section-title {
            color: #1d48b4;
            font-size: 1.8em;
            margin-bottom: 20px;
            font-family: 'Avenir Next LT Pro', sans-serif;
            font-weight: 600;
        }

        .upload-area {
            border: 3px dashed #1d48b4;
            border-radius: 8px;
            padding: 60px 40px;
            text-align: center;
            background-color: #f8f9ff;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            background-color: #e8ebff;
            border-color: #0e2a7a;
        }

        .upload-area.dragover {
            background-color: #e8ebff;
            border-color: #0e2a7a;
            transform: scale(1.02);
        }

        .upload-icon {
            width: 80px;
            height: 80px;
            margin: 0 auto 20px;
            background-color: #1d48b4;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .upload-icon svg {
            width: 40px;
            height: 40px;
            fill: white;
        }

        input[type="file"] {
            display: none;
        }

        .layout-selector {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }

        .layout-option {
            flex: 1;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            background-color: #fff;
        }

        .layout-option:hover {
            border-color: #1d48b4;
            box-shadow: 0 4px 12px rgba(29, 72, 180, 0.15);
        }

        .layout-option.selected {
            border-color: #1d48b4;
            background-color: #f0f4ff;
            box-shadow: 0 4px 12px rgba(29, 72, 180, 0.2);
        }

        .layout-option h3 {
            color: #1d48b4;
            margin-bottom: 10px;
            font-family: 'Avenir Next LT Pro', sans-serif;
        }

        .font-size-control {
            margin-top: 20px;
            padding: 20px;
            background-color: #f0f4ff;
            border-radius: 8px;
        }

        .font-size-control label {
            color: #1d48b4;
            font-weight: 600;
            margin-right: 10px;
        }

        .font-size-control input[type="number"] {
            width: 80px;
            padding: 8px;
            border: 2px solid #1d48b4;
            border-radius: 4px;
            font-size: 16px;
        }

        .btn {
            background-color: #1d48b4;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-family: 'Avenir Next LT Pro', sans-serif;
        }

        .btn:hover {
            background-color: #0e2a7a;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(29, 72, 180, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn.secondary {
            background-color: #ffd500;
            color: #1d48b4;
        }

        .btn.secondary:hover {
            background-color: #e6c000;
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .preview-container {
            margin-top: 40px;
            display: none;
        }

        .preview-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        .preview-item {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .preview-item h4 {
            color: #1d48b4;
            margin-bottom: 10px;
            font-family: 'Avenir Next LT Pro', sans-serif;
        }

        .svg-preview {
            width: 100%;
            max-width: 2048px;
            height: auto;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            margin-top: 10px;
            background-color: white;
            display: block;
        }

        .svg-preview svg {
            width: 100%;
            height: auto;
            max-width: 2048px;
            display: block;
        }

        .download-all-btn {
            margin-top: 30px;
            background-color: #ffd500;
            color: #1d48b4;
        }

        .status-message {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .status-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .main-content {
                padding: 20px;
            }

            .section {
                padding: 20px;
            }

            .layout-selector {
                flex-direction: column;
            }

            h1 {
                font-size: 2em;
            }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
</head>
<body>
    <header>
        <div class="container">
            <h1>Excel to SVG Converter</h1>
            <p class="subtitle">Trasforma le tue tabelle Excel in immagini SVG professionali</p>
        </div>
    </header>

    <div class="container">
        <div class="main-content">
            <div class="section">
                <h2 class="section-title">1. Carica il file Excel</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">
                        <svg viewBox="0 0 24 24">
                            <path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"/>
                        </svg>
                    </div>
                    <p style="font-size: 1.2em; color: #1d48b4; font-weight: 600;">Clicca o trascina qui il tuo file Excel</p>
                    <p style="color: #666; margin-top: 10px;">Formati supportati: .xlsx, .xls</p>
                    <input type="file" id="fileInput" accept=".xlsx,.xls">
                </div>
                <div class="status-message" id="statusMessage"></div>
            </div>

            <div class="section">
                <h2 class="section-title">2. Seleziona il layout</h2>
                <div class="layout-selector">
                    <div class="layout-option selected" data-layout="light">
                        <h3>Layout Light</h3>
                        <p>Design minimalista con linee sottili e colori chiari. Ideale per report e presentazioni eleganti.</p>
                    </div>
                    <div class="layout-option" data-layout="strong">
                        <h3>Layout Strong</h3>
                        <p>Design con bordi visibili e righe alternate. Perfetto per tabelle con molti dati.</p>
                    </div>
                </div>
                
                <div class="font-size-control">
                    <label for="fontSize">Dimensione font (px):</label>
                    <input type="number" id="fontSize" value="18" min="8" max="32">
                </div>
            </div>

            <div class="section" style="display: none;" id="processSection">
                <h2 class="section-title">3. Genera le immagini SVG</h2>
                <button class="btn" id="processBtn">
                    <span>Elabora tabelle</span>
                </button>
            </div>

            <div class="preview-container" id="previewContainer">
                <div class="section">
                    <h2 class="section-title">Anteprima immagini generate</h2>
                    <div class="preview-grid" id="previewGrid"></div>
                    <button class="btn download-all-btn" id="downloadAllBtn">
                        <span>Scarica tutte le immagini</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let workbookData = null;
        let selectedLayout = 'light';
        let generatedSVGs = [];

        // Upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const statusMessage = document.getElementById('statusMessage');
        const processSection = document.getElementById('processSection');
        const previewContainer = document.getElementById('previewContainer');
        const previewGrid = document.getElementById('previewGrid');

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Layout selection
        document.querySelectorAll('.layout-option').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.layout-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                selectedLayout = option.dataset.layout;
            });
        });

        function handleFile(file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    workbookData = XLSX.read(data, {
                        type: 'array',
                        cellStyles: true,
                        cellFormula: true,
                        cellDates: true
                    });
                    
                    showStatus('File caricato con successo!', 'success');
                    processSection.style.display = 'block';
                } catch (error) {
                    showStatus('Errore nel caricamento del file', 'error');
                    console.error(error);
                }
            };
            
            reader.readAsArrayBuffer(file);
        }

        function showStatus(message, type) {
            statusMessage.textContent = message;
            statusMessage.className = `status-message ${type}`;
            statusMessage.style.display = 'block';
            
            setTimeout(() => {
                statusMessage.style.display = 'none';
            }, 3000);
        }

        // Process button
        document.getElementById('processBtn').addEventListener('click', function() {
            this.disabled = true;
            this.innerHTML = '<span>Elaborazione in corso...</span>';
            
            setTimeout(() => {
                processWorkbook();
                this.disabled = false;
                this.innerHTML = '<span>Elabora tabelle</span>';
            }, 100);
        });

        function formatNumber(value) {
            if (typeof value !== 'number') return value;
            
            const absValue = Math.abs(value);
            let formatted;
            
            if (absValue >= 1000000) {
                formatted = (value / 1000000).toFixed(2).replace('.', ',') + 'M';
            } else if (absValue >= 1000) {
                formatted = (value / 1000).toFixed(2).replace('.', ',') + 'K';
            } else {
                formatted = value.toString();
            }
            
            // Remove unnecessary zeros
            formatted = formatted.replace(/,00[MK]/, '$1');
            formatted = formatted.replace(/,0([MK])/, '$1');
            
            return formatted;
        }

        function processWorkbook() {
            if (!workbookData) return;
            
            generatedSVGs = [];
            previewGrid.innerHTML = '';
            
            const fontSize = parseInt(document.getElementById('fontSize').value);
            
            workbookData.SheetNames.forEach((sheetName, sheetIndex) => {
                const worksheet = workbookData.Sheets[sheetName];
                const range = XLSX.utils.decode_range(worksheet['!ref']);
                
                // Extract data with formatting
                const tableData = [];
                for (let row = range.s.r; row <= range.e.r; row++) {
                    const rowData = [];
                    for (let col = range.s.c; col <= range.e.c; col++) {
                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
                        const cell = worksheet[cellAddress];
                        
                        let value = '';
                        let style = {};
                        let alignment = { h: 'left', v: 'middle' };
                        
                        if (cell) {
                            value = cell.v !== undefined ? cell.v : '';
                            
                            // Format numbers
                            if (typeof value === 'number') {
                                value = formatNumber(value);
                            }
                            
                            // Get cell style
                            if (cell.s) {
                                style = {
                                    bold: cell.s.font && cell.s.font.bold,
                                    italic: cell.s.font && cell.s.font.italic,
                                    underline: cell.s.font && cell.s.font.underline
                                };
                                
                                if (cell.s.alignment) {
                                    alignment = {
                                        h: cell.s.alignment.horizontal || 'left',
                                        v: cell.s.alignment.vertical || 'middle'
                                    };
                                }
                            }
                        }
                        
                        rowData.push({ value, style, alignment });
                    }
                    tableData.push(rowData);
                }
                
                if (tableData.length > 0) {
                    createSVGTables(tableData, sheetName, fontSize);
                }
            });
            
            if (generatedSVGs.length > 0) {
                previewContainer.style.display = 'block';
                showStatus(`Generate ${generatedSVGs.length} immagini SVG`, 'success');
            }
        }

        function measureText(text, fontSize, bold = false, italic = false) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            let fontStyle = '';
            if (italic) fontStyle = 'italic ';
            if (bold) fontStyle += 'bold ';
            
            context.font = `${fontStyle}${fontSize}px "Avenir Next LT Pro", sans-serif`;
            return context.measureText(text).width;
        }

        function calculateColumnWidths(tableData, fontSize) {
            const numCols = tableData[0].length;
            const colWidths = new Array(numCols).fill(0);
            const cellPaddingH = fontSize * 0.5; // Ridotto il padding orizzontale
            
            // Calculate max width for each column
            tableData.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    const text = String(cell.value);
                    const isBold = rowIndex === 0 || cell.style.bold;
                    const isItalic = cell.style.italic;
                    
                    const width = measureText(text, fontSize, isBold, isItalic) + (cellPaddingH * 2);
                    colWidths[colIndex] = Math.max(colWidths[colIndex], width);
                });
            });
            
            // Ensure minimum width
            const minWidth = 120;
            colWidths.forEach((width, index) => {
                colWidths[index] = Math.max(width, minWidth);
            });
            
            // Calculate total width before constraints
            let totalWidth = colWidths.reduce((sum, width) => sum + width, 0);
            const maxTotalWidth = 2048;
            
            // Apply 15% max width constraint per column
            const maxColumnWidth = maxTotalWidth * 0.15;
            let needsRecalculation = false;
            
            colWidths.forEach((width, index) => {
                if (width > maxColumnWidth) {
                    colWidths[index] = maxColumnWidth;
                    needsRecalculation = true;
                }
            });
            
            // Recalculate total width after applying column constraints
            totalWidth = colWidths.reduce((sum, width) => sum + width, 0);
            
            // Scale to fit within max width if still too wide
            if (totalWidth > maxTotalWidth) {
                const scale = maxTotalWidth / totalWidth;
                colWidths.forEach((width, index) => {
                    colWidths[index] = Math.floor(width * scale);
                });
            }
            
            return colWidths;
        }

        function createSVGTables(tableData, sheetName, fontSize) {
            const maxHeight = 912;
            const lineHeight = fontSize * 1.2; // Ridotta l'interlinea
            const maxLines = 3;
            const cellPaddingV = fontSize * 0.4; // Ridotto il padding verticale
            const cellPaddingH = fontSize * 0.5; // Ridotto il padding orizzontale
            const rowHeight = (maxLines * lineHeight) + (cellPaddingV * 2);
            const headerRows = 1; // Assuming first row is header
            
            const colWidths = calculateColumnWidths(tableData, fontSize);
            let totalWidth = colWidths.reduce((sum, width) => sum + width, 0);
            
            // Ensure total width is exactly 2048
            if (totalWidth > 2048) {
                const scale = 2048 / totalWidth;
                colWidths.forEach((width, index) => {
                    colWidths[index] = Math.floor(width * scale);
                });
                totalWidth = 2048;
            } else if (totalWidth < 2048) {
                // Distribute remaining space evenly
                const remainingSpace = 2048 - totalWidth;
                const extraPerColumn = remainingSpace / colWidths.length;
                colWidths.forEach((width, index) => {
                    colWidths[index] = Math.floor(width + extraPerColumn);
                });
                totalWidth = 2048;
            }
            
            let currentHeight = 0;
            let currentTableData = [];
            let tableIndex = 1;
            
            // Always include header
            const header = tableData.slice(0, headerRows);
            
            for (let i = 0; i < tableData.length; i++) {
                const isHeader = i < headerRows;
                const rowHeightToAdd = isHeader && currentTableData.length > 0 ? 0 : rowHeight;
                
                if (currentHeight + rowHeightToAdd > maxHeight && currentTableData.length > headerRows) {
                    // Create SVG for current table
                    const svg = createSVG(currentTableData, colWidths, totalWidth, sheetName, tableIndex, fontSize);
                    generatedSVGs.push({
                        name: `${sheetName}_${tableIndex}`,
                        svg: svg
                    });
                    
                    // Start new table with header
                    currentTableData = [...header];
                    currentHeight = rowHeight * headerRows;
                    tableIndex++;
                }
                
                if (!isHeader || currentTableData.length === 0) {
                    currentTableData.push(tableData[i]);
                    currentHeight += rowHeight;
                }
            }
            
            // Create final SVG
            if (currentTableData.length > headerRows) {
                const svg = createSVG(currentTableData, colWidths, totalWidth, sheetName, tableIndex, fontSize);
                generatedSVGs.push({
                    name: `${sheetName}_${tableIndex}`,
                    svg: svg
                });
            }
            
            // Add to preview
            generatedSVGs.forEach(svgData => {
                const previewItem = document.createElement('div');
                previewItem.className = 'preview-item';
                
                // Create a container div for the SVG to ensure proper sizing
                const svgContainer = document.createElement('div');
                svgContainer.className = 'svg-preview';
                svgContainer.innerHTML = svgData.svg;
                
                previewItem.innerHTML = `
                    <h4>${svgData.name}</h4>
                `;
                previewItem.appendChild(svgContainer);
                
                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'btn secondary';
                downloadBtn.style.marginTop = '10px';
                downloadBtn.textContent = 'Scarica SVG';
                downloadBtn.onclick = () => downloadSVG(svgData.name);
                previewItem.appendChild(downloadBtn);
                
                previewGrid.appendChild(previewItem);
            });
        }

        function createSVG(tableData, colWidths, totalWidth, sheetName, pageNum, fontSize) {
            const lineHeight = fontSize * 1.2; // Ridotta l'interlinea
            const maxLines = 3;
            const cellPaddingV = fontSize * 0.4; // Ridotto il padding verticale
            const cellPaddingH = fontSize * 0.5; // Ridotto il padding orizzontale
            const rowHeight = (maxLines * lineHeight) + (cellPaddingV * 2);
            const totalHeight = tableData.length * rowHeight;
            
            // Ensure SVG respects the max dimensions
            const maxWidth = 2048;
            const maxHeight = 912;
            
            // Scale width if needed
            let finalWidth = totalWidth;
            let scale = 1;
            if (totalWidth > maxWidth) {
                scale = maxWidth / totalWidth;
                finalWidth = maxWidth;
            }
            
            // Check if height exceeds max (this should be handled by pagination, but just in case)
            let finalHeight = totalHeight;
            if (totalHeight > maxHeight) {
                finalHeight = maxHeight;
            }
            
            let svg = `<svg width="${finalWidth}" height="${finalHeight}" viewBox="0 0 ${totalWidth} ${totalHeight}" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">`;
            
            // Add font definition
            svg += `
                <defs>
                    <style>
                        @font-face {
                            font-family: 'Avenir Next LT Pro';
                            src: local('Avenir Next LT Pro');
                        }
                        text {
                            font-family: 'Avenir Next LT Pro', sans-serif;
                        }
                    </style>
                </defs>
            `;
            
            if (selectedLayout === 'strong') {
                // Draw background for alternating rows - using lighter gray
                tableData.forEach((row, rowIndex) => {
                    if (rowIndex > 0 && rowIndex % 2 === 1) {
                        svg += `<rect x="0" y="${rowIndex * rowHeight}" width="${totalWidth}" height="${rowHeight}" fill="#f0f0f0"/>`;
                    }
                });
            }
            
            let currentY = 0;
            
            tableData.forEach((row, rowIndex) => {
                let currentX = 0;
                const isHeader = rowIndex === 0;
                
                row.forEach((cell, colIndex) => {
                    const cellWidth = colWidths[colIndex];
                    let text = String(cell.value);
                    
                    // Draw cell background for headers in strong layout
                    if (selectedLayout === 'strong' && isHeader) {
                        svg += `<rect x="${currentX}" y="${currentY}" width="${cellWidth}" height="${rowHeight}" fill="#1d48b4"/>`;
                    }
                    
                    // Text styling
                    let textColor = '#4d4c4c';
                    let fontWeight = 'normal';
                    let fontStyle = 'normal';
                    let textDecoration = 'none';
                    let textTransform = 'none';
                    
                    if (isHeader) {
                        textColor = selectedLayout === 'strong' ? '#ffffff' : '#1d48b4';
                        fontWeight = 'bold';
                        textTransform = 'uppercase';
                        text = text.toUpperCase();
                    } else {
                        if (cell.style.bold) fontWeight = 'bold';
                        if (cell.style.italic) fontStyle = 'italic';
                        if (cell.style.underline) textDecoration = 'underline';
                    }
                    
                    // Calculate text position based on alignment
                    let textX, textAnchor;
                    
                    // Allinea la prima colonna a sinistra e tutte le altre al centro
                    if (colIndex === 0) {
                        textX = currentX + cellPaddingH;
                        textAnchor = 'start';
                    } else {
                        textX = currentX + (cellWidth / 2);
                        textAnchor = 'middle';
                    }
                    
                    // Handle text wrapping with max 3 lines
                    const words = text.split(' ');
                    const lines = [];
                    let currentLine = '';
                    
                    words.forEach(word => {
                        const testLine = currentLine ? currentLine + ' ' + word : word;
                        const testWidth = measureText(testLine, fontSize, fontWeight === 'bold', fontStyle === 'italic');
                        
                        if (testWidth > cellWidth - (cellPaddingH * 2) && currentLine) {
                            lines.push(currentLine);
                            currentLine = word;
                        } else {
                            currentLine = testLine;
                        }
                    });
                    
                    if (currentLine) {
                        lines.push(currentLine);
                    }
                    
                    // Limit to max 3 lines and add ellipsis if needed
                    let finalLines = lines;
                    if (lines.length > maxLines) {
                        finalLines = lines.slice(0, maxLines);
                        const lastLine = finalLines[maxLines - 1];
                        
                        // Truncate last line to fit with ellipsis
                        const ellipsis = '...';
                        let truncatedLine = lastLine;
                        
                        while (measureText(truncatedLine + ellipsis, fontSize, fontWeight === 'bold', fontStyle === 'italic') > cellWidth - (cellPaddingH * 2) && truncatedLine.length > 0) {
                            truncatedLine = truncatedLine.slice(0, -1);
                        }
                        
                        finalLines[maxLines - 1] = truncatedLine + ellipsis;
                    }
                    
                    // Calculate vertical position (centrato verticalmente)
                    const totalTextHeight = finalLines.length * lineHeight;
                    const startY = currentY + (rowHeight / 2) - (totalTextHeight / 2) + fontSize * 0.8;
                    
                    // Draw text lines
                    finalLines.forEach((line, lineIndex) => {
                        svg += `<text x="${textX}" y="${startY + lineIndex * lineHeight}" 
                            fill="${textColor}" 
                            font-size="${fontSize}" 
                            font-weight="${fontWeight}"
                            font-style="${fontStyle}"
                            text-decoration="${textDecoration}"
                            text-transform="${textTransform}"
                            text-anchor="${textAnchor}"
                            dominant-baseline="middle">${escapeXml(line)}</text>`;
                    });
                    
                    // Draw borders
                    if (selectedLayout === 'light') {
                        // Only bottom border
                        const borderColor = isHeader ? '#1d48b4' : '#4d4c4c';
                        svg += `<line x1="${currentX}" y1="${currentY + rowHeight}" 
                                x2="${currentX + cellWidth}" y2="${currentY + rowHeight}" 
                                stroke="${borderColor}" stroke-width="1"/>`;
                    } else if (selectedLayout === 'strong') {
                        // All borders
                        svg += `<rect x="${currentX}" y="${currentY}" 
                                width="${cellWidth}" height="${rowHeight}" 
                                fill="none" stroke="#1d48b4" stroke-width="1"/>`;
                    }
                    
                    currentX += cellWidth;
                });
                
                currentY += rowHeight;
            });
            
            svg += '</svg>';
            return svg;
        }

        function escapeXml(text) {
            return text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }

        function downloadSVG(name) {
            const svgData = generatedSVGs.find(svg => svg.name === name);
            if (!svgData) return;
            
            const blob = new Blob([svgData.svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${name}.svg`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Make downloadSVG available globally for onclick handlers
        window.downloadSVG = downloadSVG;

        document.getElementById('downloadAllBtn').addEventListener('click', function() {
            this.innerHTML = '<span>Download in corso...</span>';
            
            generatedSVGs.forEach((svgData, index) => {
                setTimeout(() => {
                    downloadSVG(svgData.name);
                }, index * 200);
            });
            
            setTimeout(() => {
                this.innerHTML = '<span>Scarica tutte le immagini</span>';
                showStatus('Download completato!', 'success');
            }, generatedSVGs.length * 200 + 500);
        });
    </script>
</body>
</html>
